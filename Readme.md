# Microservice Gateway

## Introduction

Welcome to our microservice built in Rust! This service is designed to handle websockets, Kafka messaging, Cap'n Proto serialization, and follows the hexagonal architecture pattern with a model of actors. We utilize Actix as our actor framework.

## Features

- **Websockets**: Provides real-time communication capabilities.
- **Kafka Integration**: Enables asynchronous messaging with Kafka.
- **Cap'n Proto Serialization**: Efficient data serialization for high performance.
- **Hexagonal Architecture**: Organizes codebase into distinct layers for maintainability.
- **Model of Actors**: Utilizes the actor model for concurrency and scalability.
- **Actix Framework**: Leveraging Actix for actor-based system implementation.

## Setup

1. **Install Rust**: If you haven't already, install Rust by following the instructions on [rustup.rs](https://rustup.rs/).

2. **Clone Repository**: Clone this repository to your local machine.
   ```
   git clone https://github.com/Brekkaz/chat-gateway.git
   ```

3. **Install Dependencies**: Navigate into the project directory and install dependencies using Cargo, Rust's package manager.
    ```
    cd chat-gateway
    cargo build
    ```

4. **Configuration**: Configure the service by updating the config.toml file with your settings for Kafka, websockets, etc.

5. **Run**: Start the microservice by running:
   ```
    cargo run
   ```

## Usage
- **Websockets**: Connect to the websocket endpoint to interact with the service in real-time.
- **Kafka Messaging**: Utilize Kafka topics for asynchronous communication.
- **Cap'n Proto Serialization**: Efficiently serialize and deserialize data for communication.

## Hexagonal Architecture

This project follows the hexagonal architecture pattern, separating concerns into distinct layers:

1. **Application Layer**: Contains business logic and use cases.
2. **Adapter Layer**: Adapts external frameworks and libraries to the application layer.
3. **Domain Model**: Contains domain entities and business rules.

## Model of Actors

We model our system using the actor model, which provides a high level of concurrency and scalability 
by isolating state and communication between actors.

## Tech Debt
We acknowledge the following technical debt:

- **Documentation**
- **Testing**
- **Error Handling**
- **Capn Proto**
- **Hexagonal Architecture**
- **Messages Format**
- **Docker Alphine**

## Contributors

- Breyner Mola \<breyner.mola.9@gmail.com\>

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.
